# Vulnerability Lifecycle Report

This document outlines the full lifecycle of zero-day vulnerabilities simulated and mitigated in the "Cloud-Integrated Zero-Day Threat Research and Countermeasure System". 
The lifecycle is broken into five phases: Discovery, Exploitation, Detection, Response, and Recovery.

---

## 1. Discovery

In the discovery phase, we simulate the reconnaissance and identification of vulnerable systems using outdated operating systems and binaries.

- **Legacy Environments Used**: Ubuntu 14.04 and Windows 7 containers were deployed without patches, mimicking real-world unmaintained infrastructure.
- **Emulated Weaknesses**:
  - Presence of functions like `strcpy`, `gets`, and unsafe syscall invocations.
  - Absence of common protections (e.g., RELRO, stack canaries, ASLR).
- **Tools Used**:
  - `Ghidra` for reverse engineering binaries and identifying syscall flow.
  - Manual inspection of statically compiled binaries revealed syscall instructions like `execve`, `mmap`, and `ptrace`.

---

## 2. Exploitation

During exploitation, we intentionally triggered vulnerabilities in the binaries using fuzzing and crafted payloads.

- **Binary Attack Surface**:
  - `vuln_buffer_overflow.c` was compiled with `-fno-stack-protector` and used for stack smashing experiments.
  - A separate `syscall_test_linux.c` file issued direct syscalls.
- **Fuzzing Methodology**:
  - Used `AFL++` inside AWS CodeBuild to execute fuzzing jobs.
  - Fuzzing targeted binaries with mutated inputs to expose crash vectors.
  - Instrumented with AddressSanitizer (ASAN) and logged faults.
- **Payload Samples**:
  - NOP sleds followed by shellcode.
  - Overflow inputs (e.g., `A*300`) to corrupt return addresses.

---

## 3. Detection

Detection mechanisms were developed using a mix of behavioral rules, heuristics, and custom tools.

- **Inline Suricata Deployment**:
  - Deployed on pfSense in bridge mode with over 25 handcrafted rules.
  - Detected C2 indicators, base64 blobs in POSTs, and shellcode patterns.
- **Custom Detection Layers**:
  - `Rust hook` for intercepting `execve` and logging suspicious binaries.
  - `Ghidra` plugin generated syscall sequences for YARA correlation.
- **YARA Rules**:
  - 15+ rules created to detect static syscall strings, entropy bursts, and binary traits matching known zero-days.
- **Machine Learning Triage**:
  - Used `scikit-learn` to classify crash output (`SAFE`, `CRASH`, `HANG`).
  - YAML-based structured triage output for automation.

---

## 4. Response

Once detection confirmed a probable exploit, the response phase included containment, triage, and evidence preservation.

- **Isolation Measures**:
  - pfSense firewall rules blocked IPs, ports, and C2 signatures.
  - `execve` logs from the hook were streamed for forensic storage.
- **Forensic Validation**:
  - Captured `.vmem` images analyzed with Volatility3.
  - Plugins like `pslist`, `cmdline`, and `malfind` helped confirm injected code and unauthorized execution.
- **Triage Output**:
  - Crashed input samples labeled and stored alongside AFL traces.
  - Triage files stored as YAML with entropy, crash classification, and fix recommendations.

---

## 5. Recovery

The final phase included patching vulnerable systems and hardening against future threats.

- **Patching and Recompilation**:
  - `strcpy` replaced with `strncpy` in source code.
  - All binaries rebuilt with:
    - Stack canaries: `-fstack-protector-strong`
    - RELRO: `-Wl,-z,relro,-z,now`
    - Executable stack disabled: `-z noexecstack`
- **Rule Updates**:
  - Updated Suricata and YARA rules to include new attack variants.
  - Ghidra-generated syscall data refreshed with post-patch analysis.
- **Retesting**:
  - Binaries re-fuzzed and confirmed to be crash-free.
  - Re-deployed in secure containers with reduced permissions and syscall filtering (e.g., `seccomp`).

---

## Conclusion

This project demonstrated a complete, realistic simulation of zero-day lifecycle workflows in a cloud-integrated and local defense environment.
Every stage, from legacy system emulation to automated response, was implemented using production-ready tools and hardened scripting pipelines.
It offers a reusable blueprint for red teams, SOCs, and threat research environments looking to prototype and detect unknown vulnerabilities in hybrid infrastructure.

